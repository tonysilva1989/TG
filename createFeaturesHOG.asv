flag = 0;
fl=0;
%tam_padr = 540;
for k=0:9
%for k=3


    load(['folds/fold_' num2str(k) '.mat' ] ); % carrega a variï¿½vel fold
    load(['folds/class_' num2str(k) '.mat' ]); % carrega as classes das imagens
    
    X = [];
    for i=1:length(fold);
     %for i=2;
        disp(['Extraindo caracterï¿½sticas HOG do fold ' num2str(k) ' img: ' num2str(i)]);

        if(classFold(i)==1)
            imagem = imread(['CASIA1/AU/' fold{i}]);		
            % converted image into the YCbCr color space
            imageYCbCr = rgb2ycbcr(imagem);
            % get the chrominance component Cr (1: Y, 2: Cb, 3: Cr)
            img2 = imageYCbCr(:,:,3);
            
            out = extractHOGFeatures(img2,'CellSize',[64 64]);
            [um tam_atual] = size(out);
            
            if fl == 0
               [um tam_padr] = size(out);
               fl = 1;
            end

            if (isempty(out)) %um caso está dando array vazio
                out = zeros(1,tam_padr);
            else
                %[um, tam_atual] = size(out);
                %na primeira execução do código, X ainda está vazio e não
                %tem dimensão, neste caso ele pega antecipadamente a
                %dimensão do vetor out calculada primeiramente
                if(isempty(X))
                    tam_atual = tam_padr;
                end

                
                %se o tamanho das features atuais são maiores do que a que tem
                %na matriz e não está recebendo vetor vazio, limita o tamanho
                %da inserção das features ao tamanho da matriz de atributos                
                if tam_atual < tam_padr %caso seja menor, é preenchido com zeros
                    temp = zeros(1,tam_padr);
                    temp(1:tam_atual) = out;
                    out = temp;
                end
                
            end
            %o range abaixo garante que ele irá passar o tamanho do array
            %de features atual sempre no máximo com o tamanho da base já
            %existente
            X = [X; out(1:tam_padr)];
            
        elseif(classFold(i)==0)
			%realizar uma conversÃ£o pra tons de cinza e aplicar um filtro gaussiano (paper do LBP)?
            imagem = imread(['CASIA1/Sp/' fold{i}]);
            imageYCbCr = rgb2ycbcr(imagem);
            % get the chrominance component Cr (1: Y, 2: Cb, 3: Cr)
            img2 = imageYCbCr(:,:,3);
            out = extractHOGFeatures(img2,'CellSize',[64 64]);
            [um tam_atual] = size(out);

            %garante que a primeira vez que o código for executado, irá
            if fl == 0
               [um tam_padr] = size(out);
               fl = 1;
            end

            if (isempty(out)) %um caso está dando array vazio

                out = zeros(1,tam_padr);
            else
                
                %[um, tam_atual] = size(out);
                %na primeira execução do código, X ainda está vazio e não
                %tem dimensão, neste caso ele pega antecipadamente a
                %dimensão do vetor out calculada primeiramente
                if(isempty(X))
                    tam_atual = tam_padr;
                end
                
                %se o tamanho das features atuais são maiores do que a que tem
                %na matriz e não está recebendo vetor vazio, limita o tamanho
                %da inserção das features ao tamanho da matriz de atributos                
                if tam_atual < tam_padr %caso seja menor, é preenchido com zeros
                    temp = zeros(1,tam_padr);
                    temp(1:tam_atual) = out;
                    out = temp;
                end
            end
            %o range abaixo garante que ele irá passar o tamanho do array
            %de features atual sempre no máximo com o tamanho da base já
            %existente
            X = [X; out(1:tam_padr)];

        end
    end
    
    save(['featuresHOGC7/X_' num2str(k) '.mat'], 'X');
end